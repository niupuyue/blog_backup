---
title: swift
date: 2018-05-09 19:25:24
tags:
  - swift
---

最近因为公司业务调整，然后我需要去做ios开发，本来就非常懒的我，被逼着去学一个新的技术，真的很难受，为了打发这些比较难受的时间，将这些学习到的基础知识记录下来，方便自己以后去复习。
<!--more-->
首先要学习ios开发，第一个面临的抉择就是使用OC语言还是Swift语言。我自己是做Android的，如果一个新人想要学习Android，然后问我是学习Java语言还是Kotlin语言。我会毫不犹豫的说是Java语言。为什么呢？因为Kotlin语言更像是一个脚本，既然是脚本，那么肯定有比较方便的编程效果，为什么还要学习Java语言呢？这是因为Java语言本身既是一个非常优秀的语言，我们可以使用Java语言编写后台，移动端等等很多应用。而Kotlin语言，就相当于是解释Java语言的。那么换算到OC和Swift语言，我却选择了Swift。这是为了呢？因为我感觉Swift语言更加好理解，书写起来也是比较方便，再加上，这个Swift语言是苹果公司自己搞出来的，而OC是使用别人的语言，所以我觉得，以后肯定会有一场风波，不过照目前的形式来看，应该短期之内，没有危险。
所以，对于我来说，IOS入门语言就是Swift了

# 欢迎使用Swift
> 我去，使用不使用，管我什么事？我在这矫情什么劲？
## 关于Swift
Swift 是一种新的编程语言，用于编写 iOS，macOS，watchOS 和 tvOS 的应用程序。Swift 结合了 C 和 Objective-C 的优点并且不受 C 兼容性的限制。Swift 采用安全的编程模式并添加了很多新特性，这将使编程更简单，更灵活，也更有趣。Swift 是基于成熟而且倍受喜爱的 Cocoa 和 Cocoa Touch 框架，它的降临将重新定义软件开发。
Swift 的开发从很久之前就开始了。为了给 Swift 打好基础，苹果公司改进了编译器，调试器和框架结构。我们使用自动引用计数（Automatic Reference Counting, ARC）来简化内存管理。我们在 Foundation 和 Cocoa 的基础上构建框架栈使其完全现代化和标准化。 Objective-C 本身支持块、集合语法和模块，所以框架可以轻松支持现代编程语言技术。正是得益于这些基础工作，我们现在才能发布这样一个用于未来苹果软件开发的新语言。
> 好吧，我承认，这个Swift的介绍语言是我直接复制过来的。因为一般情况下，介绍都是在吹嘘自己的语言有多么优秀，算了，不管了，直接往下走
## Swift初见
这里我们会对Swift进行初步的认识，比如Swift的基本数据类型，一些封包操作等等。只是简单介绍，后面应该会再补充的
### 简单值
使用let声明一个常量，使用var声明一个变量(是不是非常像JS，哈哈脚本语言，果然都是一个尿性)
一个常量在编译的时候，并不一定要有一个值，但是我们只能赋值一次
```
var myValue = 12
myValue = 22
let myConstant = 100
```
在这个例子中我们可以看到，myValue是一个变量，我们可以为他多次赋值;二myConstant是一个常量，我们只能对他赋值一次
我们在声明一个对象的时候，系统会自动根据赋值内容进行类型的声明，比如上面的两个，都是整形，所以类型就是Int
如果在声明的时候我们并没有将对象的类型给规定好，那么我们可以通过一下方式再次将数据类型规定好
```
let myValue: String = "hello world"
let myInt:Int = 12
let myDouble:Double = 12.1
```
如果我们想要将一个值转换成其他类型，也是可以的，但是我们必须调用响应的方法，不然是无法直接通过隐式的方式实现的
```
let words = "my age is "
let age = 18
let ss = words + String(age)
```
其实我们还有另外一种比较简单的方式
```
let words = "我的年龄是"
let age = 22
let ss = "大家好 \(words) ，你们猜猜看，对了,\(age)"
```
我们使用[]来表示一个数组或者字典，并且通过下标和key值来访问元素。
```
var shoppingList = ["catfish", "water", "tulips", "blue paint"]
shoppingList[1] = "bottle of water"

var occupations = [
    "Malcolm": "Captain",
    "Kaylee": "Mechanic",
]
occupations["Jayne"] = "Public Relations"
```
如果我们想要从创建一个空数组或者字典，使用初始化语法
```
let emptyArray = [String]()
let emptyDictionary = [String: Float]()
```
### 控制流
> 所谓的控制流就是逻辑判断，条件循环
这个控制流里面也是包括if条件判断和for循环等操作的

那么总的介绍我们就先说这么多，下面我们具体来看看

# Swift教程
## 基础部分
### 常量和变量
常量和变量把一个名字（比如 maximumNumberOfLoginAttempts 或者 welcomeMessage ）和一个指定类型的值（比如数字 10 或者字符串 "Hello" ）关联起来。常量的值一旦设定就不能改变，而变量的值可以随意更改。
### 声明常量和变量
常量和变量必须在使用前声明，用 let 来声明常量，用 var 来声明变量。下面的例子展示了如何用常量和变量来记录用户尝试登录的次数：
```
let maximumNumberOfLoginAttempts = 10
var currentLoginAttempt = 0
```
这两行代码可以被理解为：

“声明一个名字是 maximumNumberOfLoginAttempts 的新常量，并给它一个值 10 。然后，声明一个名字是 currentLoginAttempt 的变量并将它的值初始化为 0 。”

在这个例子中，允许的最大尝试登录次数被声明为一个常量，因为这个值不会改变。当前尝试登录次数被声明为一个变量，因为每次尝试登录失败的时候都需要增加这个值。

你可以在一行中声明多个常量或者多个变量，用逗号隔开
```
var x = 0.0, y = 0.0, z = 0.0
```
> 如果你的代码中有不需要改变的值，请使用 let 关键字将它声明为常量。只将需要改变的值声明为变量。
### 类型标注
当你声明常量或者变量的时候可以加上类型标注（type annotation），说明常量或者变量中要存储的值的类型。如果要添加类型标注，需要在常量或者变量名后面加上一个冒号和空格，然后加上类型名称。

这个例子给 welcomeMessage 变量添加了类型标注，表示这个变量可以存储 String 类型的值：
```
var welcomeMessage: String
```
声明中的冒号代表着“是...类型”，所以这行代码可以被理解为：

“声明一个类型为 String ，名字为 welcomeMessage 的变量。”

“类型为 String ”的意思是“可以存储任意 String 类型的值。”

welcomeMessage 变量现在可以被设置成任意字符串：
```
welcomeMessage = "Hello"
```
你可以在一行中定义多个同样类型的变量，用逗号分割，并在最后一个变量名之后添加类型标注：
```
var red, green, blue: Double
```
> 一般来说你很少需要写类型标注。如果你在声明常量或者变量的时候赋了一个初始值，Swift可以推断出这个常量或者变量的类型，请参考类型安全和类型推断。在上面的例子中，没有给 welcomeMessage 赋初始值，所以变量 welcomeMessage 的类型是通过一个类型标注指定的，而不是通过初始值推断的
### 常量和变量的命名
你可以用任何你喜欢的字符作为常量和变量名，包括 Unicode 字符
```
let π = 3.14159
let 你好 = "你好世界"
let 🐶🐮 = "dogcow"
```
常量与变量名不能包含数学符号，箭头，保留的（或者非法的）Unicode 码位，连线与制表符。也不能以数字开头，但是可以在常量与变量名的其他地方包含数字。

一旦你将常量或者变量声明为确定的类型，你就不能使用相同的名字再次进行声明，或者改变其存储的值的类型。同时，你也不能将常量与变量进行互转。
> 如果你需要使用与Swift保留关键字相同的名称作为常量或者变量名，你可以使用反引号（`）将关键字包围的方式将其作为名字使用。无论如何，你应当避免使用关键字作为常量或变量名，除非你别无选择。
你可以更改现有的变量值为其他同类型的值，在下面的例子中，friendlyWelcome的值从"Hello!"改为了"Bonjour!"
```
var friendlyWelcome = "Hello!"
friendlyWelcome = "Bonjour!"
// friendlyWelcome 现在是 "Bonjour!"
```
与变量不同，常量的值一旦被确定就不能更改了。尝试这样做会导致编译时报错：
```
let languageName = "Swift"
languageName = "Swift++"
// 这会报编译时错误 - languageName 不可改变
```
### 输出常量和变量
你可以用print(_:separator:terminator:)函数来输出当前常量或变量的值:
```
print(friendlyWelcome)
// 输出 "Bonjour!"
```
print(_:separator:terminator:) 是一个用来输出一个或多个值到适当输出区的全局函数。如果你用 Xcode，print(_:separator:terminator:) 将会输出内容到“console”面板上。separator 和 terminator 参数具有默认值，因此你调用这个函数的时候可以忽略它们。默认情况下，该函数通过添加换行符来结束当前行。如果不想换行，可以传递一个空字符串给 terminator 参数--例如，print(someValue, terminator:"") 。关于参数默认值的更多信息，请参考默认参数值。

Swift 用字符串插值（string interpolation）的方式把常量名或者变量名当做占位符加入到长字符串中，Swift 会用当前常量或变量的值替换这些占位符。将常量或变量名放入圆括号中，并在开括号前使用反斜杠将其转义：
```
print("The current value of friendlyWelcome is \(friendlyWelcome)")
// 输出 "The current value of friendlyWelcome is Bonjour!
```
> 字符串插值所有可用的选项
### 整数
整数就是没有小数部分的数字，比如 42 和 -23 。整数可以是 有符号（正、负、零）或者 无符号（正、零）。

Swift 提供了8，16，32和64位的有符号和无符号整数类型。这些整数类型和 C 语言的命名方式很像，比如8位无符号整数类型是UInt8，32位有符号整数类型是 Int32 。就像 Swift 的其他类型一样，整数类型采用大写命名法。
### 整数的范围
你可以访问不同整数类型的 min 和 max 属性来获取对应类型的最小值和最大值：
```
let minValue = UInt8.min  // minValue 为 0，是 UInt8 类型
let maxValue = UInt8.max  // maxValue 为 255，是 UInt8 类型
```
min 和 max 所传回值的类型，正是其所对的整数类型(如上例UInt8, 所传回的类型是UInt8)，可用在表达式中相同类型值旁。
### Int
一般来说，你不需要专门指定整数的长度。Swift 提供了一个特殊的整数类型Int，长度与当前平台的原生字长相同：
- 在32位平台上，Int 和 Int32 长度相同。
- 在64位平台上，Int 和 Int64 长度相同。
除非你需要特定长度的整数，一般来说使用 Int 就够了。这可以提高代码一致性和可复用性。即使是在32位平台上，Int 可以存储的整数范围也可以达到 -2,147,483,648 ~ 2,147,483,647 ，大多数时候这已经足够大了。
### UInt
Swift 也提供了一个特殊的无符号类型 UInt，长度与当前平台的原生字长相同：
- 在32位平台上，UInt 和 UInt32 长度相同。
- 在64位平台上，UInt 和 UInt64 长度相同。
> 尽量不要使用UInt，除非你真的需要存储一个和当前平台原生字长相同的无符号整数。除了这种情况，最好使用Int，即使你要存储的值已知是非负的。统一使用Int可以提高代码的可复用性，避免不同类型数字之间的转换，并且匹配数字的类型推断
### 浮点数
浮点数是有小数部分的数字，比如 3.14159 ，0.1 和 -273.15。

浮点类型比整数类型表示的范围更大，可以存储比 Int 类型更大或者更小的数字。Swift 提供了两种有符号浮点数类型：

- Double表示64位浮点数。当你需要存储很大或者很高精度的浮点数时请使用此类型。
- Float表示32位浮点数。精度要求不高的话可以使用此类型。
> Double精确度很高，至少有15位数字，而Float只有6位数字。选择哪个类型取决于你的代码需要处理的值的范围，在两种类型都匹配的情况下，将优先选择 Double。
### 类型安全和类型推断
Swift 是一个类型安全（type safe）的语言。类型安全的语言可以让你清楚地知道代码要处理的值的类型。如果你的代码需要一个String，你绝对不可能不小心传进去一个Int。

由于 Swift 是类型安全的，所以它会在编译你的代码时进行类型检查（type checks），并把不匹配的类型标记为错误。这可以让你在开发的时候尽早发现并修复错误。

当你要处理不同类型的值时，类型检查可以帮你避免错误。然而，这并不是说你每次声明常量和变量的时候都需要显式指定类型。如果你没有显式指定类型，Swift 会使用类型推断（type inference）来选择合适的类型。有了类型推断，编译器可以在编译代码的时候自动推断出表达式的类型。原理很简单，只要检查你赋的值即可。

因为有类型推断，和 C 或者 Objective-C 比起来 Swift 很少需要声明类型。常量和变量虽然需要明确类型，但是大部分工作并不需要你自己来完成。

当你声明常量或者变量并赋初值的时候类型推断非常有用。当你在声明常量或者变量的时候赋给它们一个字面量（literal value 或 literal）即可触发类型推断。（字面量就是会直接出现在你代码中的值，比如 42 和 3.14159 。）

例如，如果你给一个新常量赋值 42 并且没有标明类型，Swift 可以推断出常量类型是 Int ，因为你给它赋的初始值看起来像一个整数：
```
let meaningOfLife = 42
// meaningOfLife 会被推测为 Int 类型
```
同理，如果你没有给浮点字面量标明类型，Swift 会推断你想要的是 Double：
```
let pi = 3.14159
// pi 会被推测为 Double 类型
```
当推断浮点数的类型时，Swift 总是会选择 Double 而不是Float。
如果表达式中同时出现了整数和浮点数，会被推断为 Double 类型：
```
let anotherPi = 3 + 0.14159
// anotherPi 会被推测为 Double 类型
```
原始值 3 没有显式声明类型，而表达式中出现了一个浮点字面量，所以表达式会被推断为 Double 类型。
### 数值型字面量
整数字面量可以被写作：

- 一个十进制数，没有前缀
- 一个二进制数，前缀是0b
- 一个八进制数，前缀是0o
- 一个十六进制数，前缀是0x
下面的所有整数字面量的十进制值都是17:
```
let decimalInteger = 17
let binaryInteger = 0b10001       // 二进制的17
let octalInteger = 0o21           // 八进制的17
let hexadecimalInteger = 0x11     // 十六进制的17
```
浮点字面量可以是十进制（没有前缀）或者是十六进制（前缀是 0x ）。小数点两边必须有至少一个十进制数字（或者是十六进制的数字）。十进制浮点数也可以有一个可选的指数（exponent)，通过大写或者小写的 e 来指定；十六进制浮点数必须有一个指数，通过大写或者小写的 p 来指定。
如果一个十进制数的指数为 exp，那这个数相当于基数和10^exp的乘积：

1. 1.25e2 表示 1.25 × 10^2，等于 125.0。
2. 1.25e-2 表示 1.25 × 10^-2，等于 0.0125。
如果一个十六进制数的指数为exp，那这个数相当于基数和2^exp的乘积：

1. 0xFp2 表示 15 × 2^2，等于 60.0。
2. 0xFp-2 表示 15 × 2^-2，等于 3.75。
下面的这些浮点字面量都等于十进制的12.1875：
```
let decimalDouble = 12.1875
let exponentDouble = 1.21875e1
let hexadecimalDouble = 0xC.3p0
```
数值类字面量可以包括额外的格式来增强可读性。整数和浮点数都可以添加额外的零并且包含下划线，并不会影响字面量：
```
let paddedDouble = 000123.456
let oneMillion = 1_000_000
let justOverOneMillion = 1_000_000.000_000_1
```
### 数值型类型转换
通常来讲，即使代码中的整数常量和变量已知非负，也请使用Int类型。总是使用默认的整数类型可以保证你的整数常量和变量可以直接被复用并且可以匹配整数类字面量的类型推断。

只有在必要的时候才使用其他整数类型，比如要处理外部的长度明确的数据或者为了优化性能、内存占用等等。使用显式指定长度的类型可以及时发现值溢出并且可以暗示正在处理特殊数据。
### 整数转换
不同整数类型的变量和常量可以存储不同范围的数字。Int8类型的常量或者变量可以存储的数字范围是-128~127，而UInt8类型的常量或者变量能存储的数字范围是0~255。如果数字超出了常量或者变量可存储的范围，编译的时候会报错：
```
let cannotBeNegative: UInt8 = -1
// UInt8 类型不能存储负数，所以会报错
let tooBig: Int8 = Int8.max + 1
// Int8 类型不能存储超过最大值的数，所以会报错
```
由于每种整数类型都可以存储不同范围的值，所以你必须根据不同情况选择性使用数值型类型转换。这种选择性使用的方式，可以预防隐式转换的错误并让你的代码中的类型转换意图变得清晰。

要将一种数字类型转换成另一种，你要用当前值来初始化一个期望类型的新数字，这个数字的类型就是你的目标类型。在下面的例子中，常量twoThousand是UInt16类型，然而常量one是UInt8类型。它们不能直接相加，因为它们类型不同。所以要调用UInt16(one)来创建一个新的UInt16数字并用one的值来初始化，然后使用这个新数字来计算：
```
let twoThousand: UInt16 = 2_000
let one: UInt8 = 1
let twoThousandAndOne = twoThousand + UInt16(one)
```
现在两个数字的类型都是 UInt16，可以进行相加。目标常量 twoThousandAndOne 的类型被推断为 UInt16，因为它是两个 UInt16 值的和。

SomeType(ofInitialValue) 是调用 Swift 构造器并传入一个初始值的默认方法。在语言内部，UInt16 有一个构造器，可以接受一个UInt8类型的值，所以这个构造器可以用现有的 UInt8 来创建一个新的 UInt16。注意，你并不能传入任意类型的值，只能传入 UInt16 内部有对应构造器的值。不过你可以扩展现有的类型来让它可以接收其他类型的值（包括自定义类型）






