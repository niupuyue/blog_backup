---
title: 源码分析(五) JVM内存模型和Java内存模型
date: 2020-03-06 22:09:13
tags:
 - 源码分析
---

JVM内存模型和Java内存模型
<!--more-->

先来看一下内存模型图，这个图是在网上下载的，基本上可以满足我们需要
![内存结构模型图](/assets/sourcecode/jvm_01.jpg)

JVM的内存模型总共分为五个区域，分别是程序计数器，本地方法栈，java虚拟机栈，java堆，方法区

1. 程序计数器
为了线程切换能够恢复到正确的执行位置，每条线程都有一个独立的程序计数器，各条线程之间程序计数器不相互影响，独立存储，我们称这块区域为”线程私有“的内存。计数器记录的是正在执行的虚拟机字节码指令的地址

2. 本地方法栈：虚拟机执行native方法的服务

3. Java虚拟机栈：方法调用时，与方法相关的数据都会方法虚拟机栈中。每一个方法在执行的时候都会在虚拟机栈中创建一个栈帧，用于存储局部变量表，操作数栈，动态链接(例如多态就要动态链接以确定引用的状态)，方法出口等信息。局部变量表用来存放在编译期可知的基本数据类型(boolean,byte,int,char,float,double,long,short)，对象引用(reference类型，他不等于对象本身，可能是指向对象起始地址的引用指针)，returnAddress类型(指向一个字节码指令的地址)。其中 64 位长度的 long 和 double 类型的数据会占用 2 个局部变量空间（Slot），其余的数据类型只占用 1 个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

4. Java堆：是被所有线程共享的内存区域，在虚拟机启动的时候就会创建Java堆。唯一的目的就是为了存放实例对象，几乎所有的实例对象都会在这里分配内存，Java的垃圾回收机制操作的也就是这块区域。

5. 方法区：与Java堆一样也是被所有线程共享的内存区域，用于存储已经被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码

一个类中主要有：常量、成员变量、静态变量、局部变量。其中常量与静态变量位于方法区，成员变量位于 Java 堆，局部变量位于 Java 虚拟机栈。
  运行时常量池： 是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。
  Java内存模型：每个线程都有一个工作内存，线程只可以修改自己工作内存中的数据，然后再同步回主内存，主内存由多个线程共享。

Java内存模型
![Java内存模型图](/assets/sourcecode/jvm_02.jpg)

Java Memory Model (JAVA 内存模型，JMM）描述线程之间如何通过内存(memory)来进行交互。具体说来，JVM中存在一个主存区（Main Memory或Java Heap Memory），对于所有线程进行共享，而每个线程又有自己的工作内存（Working Memory，实际上是一个虚拟的概念），工作内存中保存的是主存中某些变量的拷贝，线程对所有变量的操作并非发生在主存区，而是发生在工作内存中，而线程之间是不能直接相互访问的，变量在程序中的传递，是依赖主存来完成的

JMM描述了Java程序中各种变量（线程共享变量）的访问规则，以及在JVM中将变量存储到内存中读取出变量这样的底层细节。
所有的变量都存储在主内存中，每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本（主内存中变量的一份拷贝）。
  JMM的两条规定
  1、线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写；
  2、不同的线程之间无法直接访问其他线程工作内存中的变量，线程变量值的传递需要通过主内存来完成

